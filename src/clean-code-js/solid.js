//=================== SOLID =====================
// 1. Single Responsibility Principle (SRP)
// As stated in Clean Code, 
// ========== "There should never be more than one reason for a class to change". ==========
// It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight.
// The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change.
// Minimizing the amount of times you need to change a class is important. 
// It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase.

// BAD
class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
    }
  }

  verifyCredentials() {
  }
}

// GOOD
// This should be exclusive file.
class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
  }
}

// This should be exclusive file.
import UserAuth from './user-auth'

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
    }
  }
}

//========================================
// 2. Open/Closed Principle (OCP)
// As stated by Bertrand Meyer, "software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification."
// What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.

// BAD (VERY BAD)
class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = "ajaxAdapter";
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = "nodeAdapter";
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === "ajaxAdapter") {
      return makeAjaxCall(url).then(response => {
        // transform response and return
      });
    } else if (this.adapter.name === "nodeAdapter") {
      return makeHttpCall(url).then(response => {
        // transform response and return
      });
    }
  }
}

function makeAjaxCall(url) {
  // request and return promise
}

function makeHttpCall(url) {
  // request and return promise
}

// GOOD
class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = "nodeAdapter";
  }

  request(url) {
    // request and return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then(response => {
      // transform response and return
    });
  }
}

//========================================
// 3. Liskov Substitution Principle (LSP)
// This is a scary term for a very simple concept. 
// It's formally defined as "If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T)
// without altering any of the desirable properties of that program (correctness, task performed, etc.)." That's an even scarier definition.

// The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting
// incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but 
// if you model it using the "is-a" relationship via inheritance, you quickly get into trouble.

// BAD
class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {}

  render(area) {}

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.forEach(rectangle => {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);

// GOOD
class Shape {
  setColor(color) {}

  render(area) {}
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach(shape => {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);


//========================================
// 4. Interface Segregation Principle (ISP)
// JavaScript doesn't have interfaces so this principle doesn't apply as strictly as others.
// However, it's important and relevant even with JavaScript's lack of type system.

// ISP states that "Clients should not be forced to depend upon interfaces that they do not use." Interfaces are implicit contracts in JavaScript because of duck typing.

// A good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. 
// Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings.
// Making them optional helps prevent having a "fat interface".

// BAD
class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.settings.animationModule.setup();
  }

  traverse() {}
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  animationModule() {} // Most of the time, we won't need to animate when traversing.
});


// GOOD
class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
    }
  }

  traverse() {}
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  options: {
    animationModule() {}
  }
});


//========================================
// 5. Dependency Inversion Principle (DIP)
// This principle states two essential things:
// - High-level modules should not depend on low-level modules. Both should depend on abstractions.
// - Abstractions should not depend upon details. Details should depend on abstractions.

// This can be hard to understand at first, but if you've worked with AngularJS, you've seen an implementation of this principle in the form of Dependency Injection (DI).
// While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. 
// It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules.
// Coupling is a very bad development pattern because it makes your code hard to refactor.

// As stated previously, JavaScript doesn't have interfaces so the abstractions that are depended upon are implicit contracts.
// That is to say, the methods and properties that an object/class exposes to another object/class. 
// In the example below, the implicit contract is that any Request module for an InventoryTracker will have a requestItems method.

// BAD
class InventoryRequester {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {}
}

class InventoryTracker {
  constructor(items) {
    this.items = items;

    // BAD: We have created a dependency on a specific request implementation.
    // We should just have requestItems depend on a request method: `request`
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach(item => {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker(["apples", "bananas"]);
inventoryTracker.requestItems();

// GOOD
class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach(item => {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {}
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = ["WS"];
  }

  requestItem(item) {}
}

// By constructing our dependencies externally and injecting them, we can easily
// substitute our request module for a fancy new one that uses WebSockets.
const inventoryTracker = new InventoryTracker(
  ["apples", "bananas"],
  new InventoryRequesterV2()
);
inventoryTracker.requestItems();
